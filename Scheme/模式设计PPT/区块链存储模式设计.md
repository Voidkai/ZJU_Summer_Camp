---
marp: true
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.jpg')

---

# 区块链分布式存储模式设计

---
## 全节点

- 一直在线
- 维护完整的区块链信息
- 监听别的矿工挖出来的区块，验证其合法性
- 挖矿
  - 决定区块链沿着哪一个分支继续发展下去？
  - 当出现等长的分支的时候，选择哪一个分支？

---
## 轻节点
- 不是一直在线
- 不用保存整个区块链，只保存每个区块的块头
- 不用保存全部交易，只保存与自己相关的交易
- 只能检测哪个是最长链，不知道那个是最长合法链


---
## 比特币的安全性

1. 密码学所保证的安全性
   - 节点签名不可伪造、身份不可伪造
   - 不可伪造非法交易
2. 共识机制所保证的安全性

---
## 区块链存储结构

1. 区块：链上保存交易信息的存储单元
   1. 区块头：哈希值
   2. 区块体：交易信息
2. 节点
   1. 轻节点
   2. 全节点

---
## 基于纠删码的区块链文件存储模型

区块链节点将其保存的完整区块文件通过纠删码技术编码成多个编码块，每个节点仅保留部分编码块，全网节点拥有完整的编码块信息，使得全网中各个节点在尽可能减少存储空间占用的同时，又能恢复出完整的区块文件。

---

![](.\编码过程.png)

---
## 模型：

### 编码(RS码)存储过程

1.在一个指定大小的区块文件还为生成时，节点都采用副本方式存储。同时，在区块文件生成**根据公钥哈希模q所得值进行分组**
2. 组内通过广播的方式进行组内节点进行纠删码编码存储。

---
### 编码(RS码)存储过程
设组数为q， 组内节点数为$n_{0},n_{1},...,n_{q-1}$, 第$i$ 组每个节点所需保存的编码块个数以及编码数据大小为, 其中${\lambda}^{'}$为组内容错率：
$$
第i组各节点编码块个数:n_{node} = \frac{k+r}{n_{i}}=\frac{k}{(1-{\lambda}^{'})n_i}\\
第i组各节点保存编码块大小:m_{node} = \frac{m}{k}n_{node} = \frac{m}{(1-{\lambda}^{'})n_i}\\
其中\ \ \ i\in[0, q-1],{\lambda}^{'} = 1-\sqrt[q]{1-\lambda}
$$

$$
全网节点保存编码总大小:m_{total} = \sum_{i=0}^{q-1}\frac{m}{(1-\lambda^{'})n_i}\times n_i = \frac{q\times m}{1-\lambda^{'}} =  m\times \frac{q}{\sqrt[q]{1-\lambda}}
$$

---
## 51% 攻击
51% 攻击，又被称为 Majority attack。这种攻击是通过控制网络算力实现双花攻击。如果攻击者控制了网络中 50% 以上的算力，那么在他控制算力的这段时间，他可以将区块逆转，进行反向交易，实现双花。

在 PoW 共识协议里，区块链系统同时允许存在多条分叉链，而每一条链都可以对外申明自己是正确的，但是在区块链的设计理念中有一个最长有效原理：“不论在什么时候，最长的链会被认为是拥有最多工作的主链。”

---
## 可容忍恶意节点数分析
通过 PoW 算法，比特币可以允许全网有 50% 的节点错误的情况下，依然能够完成共识。并且，以区块链中的节点分为$q=5$组为例。每组节点数为$n_{0},n_{1},n_{2},n_{3},n_{4}$,且每组中包含order节点用于发送编码控制信息以及保存分组中元数据，其余都仅作为存储节点。同理，以组为单位，则该区块链能够允许全网有50%组错误的情况下，依然能够完成共识。

---
## 可容忍恶意节点数分析
$$
 以q=5为例区块链上可容忍恶意节点总数的平均值:\\
n_{tolerant} = \sum_{\{i,j\}}^{0\leq i<j\leq 4}([\frac{n_{i}}{2}] +[\frac{n_{j}}{2}]) / C_{5}^2 \\
$$
$$
不考虑组中节点数为权值时:\\
Max(n_{tolerant}) = n_0+n_1+[\frac{n_2}{2}]+[\frac{n_3}{2}]+[\frac{n_4}{2}]，\\其中假设n_0,n_1节点数最多\\
考虑节点数权值时:
n_{tolerant} = [\frac{n_{total}}{2}]
$$

---
一般情况下：
$$
可容忍恶意组数: q^{'} = \lfloor \frac{q}2 \rfloor，\\
$$
$$
所有分组都有恶意节点情况下:可容忍恶意节点总数的平均值:\\
n_{avg} = \sum_{\{i_{0},i_{i},...,i_{q^{'}-1}\}}^{0\leq i_{0}<...< i_{q^{'}-1}\leq q-1}(\sum_{j}^{0\leq j\leq q^{'} - 1}\lfloor \frac{n_{i_{j}}}2\rfloor) / C_{q}^{q^{'}} < \frac{n_{taotal}}{2}

\\
区块链节点总数: n_{total} = \sum_{i}^{0\leq i \leq q-1} n_i
$$


---

### 解码恢复过程

1. 客户端向某个节点发起区块链查询请求
2. 节点向Orders节点发起编码块请求
3. Orders节点向已连接的peer节点广播该节点
4. 向请求节点传输编码块

---

### 编码状态下的同步更新方法

通过发送节点账本快照判断邻近节点是否需要发送更新给同步请求发起节点。

1. 邻近节点为未编码节点：直接将区块信息返回给发起同步请求节点
2. 邻近节点为编码节点：通过解码恢复方法恢复区块数据后发送

